* 设计一个动态平衡的hash表
* leetcode 128: Longist Consecutive Sequence
** 思路
初次拿到这个题目我想到的是先进行排序，然后再遍历取出连续的子数组。
第二个方法就是用hash，一个集合set中存入所有数字，遍历数组中的每个数字，如果在集合中存在，则将其移除，然后分别取pre和next，如果依旧存在，依次下去，直到pre和next不存在为止。
** 方法1：排序法
#+BEGIN_SRC python
  class Solution:
      def longestConsecutive(self, nums):
          """
          :type nums: List[int]
          :rtype: int
          """
          sorted = self.quickSort(nums, 0, len(nums) - 1)
          ans = 1
          length = 1
          for index in range(1, len(sorted)):
              if (sorted[index] == sorted[index - 1]):
                  continue

              if (sorted[index] - sorted[index - 1] == 1):
                  length += 1
              else:
                  if ans < length:
                      print(length, ans)
                      ans = length
                  length = 1
          return ans

      def quickSort(self, liste1, left, right):
          if left >= right:
              return liste1
          key = liste1[left]
          low = left
          high = right
          while left < right:
              while left < right and liste1[right] >= key:
                  right -= 1
              liste1[left] = liste1[right]
              while left < right and liste1[left] <= key:
                  left += 1
              liste1[right] = liste1[left]
          liste1[right] = key
          self.quickSort(liste1, low, left - 1)
          self.quickSort(liste1, left + 1, high)
          return liste1
#+END_SRC
* 布隆过滤器
* 实现一个并查集
* leetcode 155
