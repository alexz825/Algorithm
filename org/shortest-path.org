* 最短路径相关算法
** 介绍
   [[https://zh.wikipedia.org/wiki/%25E6%259C%2580%25E7%259F%25AD%25E8%25B7%25AF%25E9%2597%25AE%25E9%25A2%2598][wiki介绍]]，是旨在寻找图中两个点之间最短路径问题
** 相关算法
*** Dijkstra
    Dijkstra是典型的单源最短路径算法，用于计算一个点到其他所有点的最短路径，但是路径不能是负权。算法时间复杂度O((m+n)logn)。
**** 算法介绍
     1. 我们可以使用二维数组e(n*n)来表示一个图，再用一个数组d来表示顶点1到各个顶点的初始路程。
     2. 第一步我们先找一个离起点顶点1最近的点，比如是顶点3，那么我们顶点1到顶点3就是最短路程，不可能更短了，也不可能通过其他路径到达顶点3形成更短的路径
     3. 确定顶点3之后我们来看顶点3可以连接的其他顶点，比如是顶点4和顶点5，如果d[3]+e[3][4] > d[4],则通过3绕到4的路径也认为不可取，如果d[3]+e[3][4]<d[4],则更新d[4]的值，同理判断d[3]+e[3][5]和d[5]
     4. 再接下来就是重复2,3步骤，取出剩下数组中最短的路径，判断并更新d中的值，直到d中所有的数组都被比对过了，就可以确定顶点1到其他各个点的最短距离。
**** 代码
     #+BEGIN_SRC python
       inf = 999999
       n = 6 # 顶点数
       graph = [[1, 2, 1], [2, 4, 3], [1, 3, 12], [2, 3, 9], [4, 3, 4], [4, 5, 13], [3, 5, 5], [4, 6, 15], [5, 6, 4]] # 每个数组数字从左到右依次是每条边的，起点，终点，权重
       # 初始化数组，得到图的二维数组
       e = []
       for i in n:
	   x = []
	   for j in n:
	       if i == j:
		   x.append(0)
	       else:
		   x.append(inf)
	   e.append(x)

       for i in graph:
	   e[i[0]][i[1]] = i[2]

       d = [] # 顶点1到各个顶点的初始化距离
       for item, index in enumerate(e):
	   d.append(item[0][index])

       book = [] # 初始化一个数组来记录某个点是否已经走过
       for i in n:
	   book.append(0)
       book[0] = 1
       for i in n-1:
	   min = inf
	   u = 0
	   for j in n: # 找到当前顶点1直达其他点的最短距离的那个点
	       if book[j] == 0 and d[j] < min:
		   min = d[j]
		   u = j
	   book[u] = 1
	   for k in n: # 判断通过这个点到达其他点距离是否更近，如果更近，则更新数组d
	       if e[u][k] < inf:
		   if d[k] > d[u] + e[u][k]:
		       d[k] = d[u] + e[u][k]
    
     #+END_SRC
     
*** floyd
    floyd-warshall算法用来解决任意两点之间最短路径的一种算法，用于处理有向图或负权的最短路径问题，但不可有负权回路。
**** 算法思想
     floyd算法属于动态规划的范围。
     如果让任意两个点路程变短，只要引入第三个点，就可以了，当两个点之间不允许第三个点时，则这些城市之间最短路程就是初始最短路程。
     我们假定只允许通过1号顶点，求任意两点之间的最短距离，则我们需要判定e[i][1]+e[1][j]是否比e[i][j]要小，如果更小，则表示我们需要更新e[i][j]之间的值为e[i][1]+e[1][j]。代码示例如下：
     #+BEGIN_SRC python
       for i in n:
	   for j in n:
	       if e[i][1] + e[1][j] < e[i][j]:
		   e[i][j] = e[i][1] + e[1][j]
     #+END_SRC
     依次类推，判断只允许通过k号顶点进行中转
     #+BEGIN_SRC python
       for k in n:
	   for i in n:
	       for j in n:
		   if e[i][k] + e[k][i] < e[i][j]:
		       e[i][j] = e[i][k] + e[k][i]
     #+END_SRC
     上图还需要注意一个，如果两个点之间不通，需要判定一下，假如两个点不通为inf，则代码：
     #+BEGIN_SRC python
       for k in n:
	   for i in n:
	       for j in n:
		   if e[i][k] < inf and e[j][k] < inf and e[i][k] + e[k][i] < e[i][j]:
		       e[i][j] = e[i][k] + e[k][i]
     #+END_SRC
     这五行代码就是floyd算法的核心代码。
     由上面代码可以看出时间复杂度为O(n3)，空间复杂度为O(n2)，因为需要两个数组来保存值。
*** bellman ford
    也是求单源最短路径的一种算法，主要用于解决负权值，与Dijkstra算法相比来说，实现简单，但是时间复杂度高，高达O(VE)，V、E分别为节点和边的数量。
**** 算法思路
     与Dijkstra算法类似，都是以松弛操作为基础，即估计的最短的值渐渐被更加准确的值替代，直到最佳解出现。但是不同的是bellman ford算法对所有边都进行松弛操作。
     简单的代码示例如下：
     #+BEGIN_SRC python
       # n 顶点数
       # v 边数
       for i in n-1: # 进行n-1轮松弛
	   for j in m: # 枚举每一条边
	       if dis[v[i]] > dis[u[i]] + w[i]:
		   dis[v[i]] = dis[u[i]] + w[i]
     #+END_SRC
     用一句话就可以代替：对所有边进行n-1次松弛操作。
*** SPFA:对bellman ford算法的优化
    松弛操作必定只会发生在最短路径前导节点松弛成功过的节点上，用一个队列记录松弛过的节点，可以避免了冗余计算。复杂度可以降低到O(kE)，k是个比较小的系数(并且在绝大多数的图中，k<=2，然而在一些精心构造的图中可能会上升到很高)
**** 算法思路
     每次选取队首顶点u，对顶点u的所有出边进行松弛操作。例如有一条u->v的边，如果通过u->v这条边是的源点到顶点v的最短路程变短，且顶点v不在当前的队列，就将顶点v放入对尾，需要注意的是，同一个顶点同时在队列中出现多次是毫无意义的，所以我们需要一个数组来判重（判断哪些点已经在队列中）。在对顶点u的所有出边松弛完毕后，就将u出对。接下来不断从队列中取出新的队首顶点再进行如上操作，直至队列空为止。
