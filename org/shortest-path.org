* 最短路径相关算法
** 介绍
   [[https://zh.wikipedia.org/wiki/%25E6%259C%2580%25E7%259F%25AD%25E8%25B7%25AF%25E9%2597%25AE%25E9%25A2%2598][wiki介绍]]，是旨在寻找图中两个点之间最短路径问题
** 相关算法
*** Dijkstra
    Dijkstra是典型的单源最短路径算法，用于计算一个点到其他所有点的最短路径，但是路径不能是负权。
**** 算法介绍
     1. 我们可以使用二维数组e(n*n)来表示一个图，再用一个数组d来表示顶点1到各个顶点的初始路程。
     2. 第一步我们先找一个离起点顶点1最近的点，比如是顶点3，那么我们顶点1到顶点3就是最短路程，不可能更短了，也不可能通过其他路径到达顶点3形成更短的路径
     3. 确定顶点3之后我们来看顶点3可以连接的其他顶点，比如是顶点4和顶点5，如果d[3]+e[3][4] > d[4],则通过3绕到4的路径也认为不可取，如果d[3]+e[3][4]<d[4],则更新d[4]的值，同理判断d[3]+e[3][5]和d[5]
     4. 再接下来就是重复2,3步骤，取出剩下数组中最短的路径，判断并更新d中的值，直到d中所有的数组都被比对过了，就可以确定顶点1到其他各个点的最短距离。
**** 代码
     #+BEGIN_SRC python
       inf = 999999
       n = 6 # 顶点数
       graph = [[1, 2, 1], [2, 4, 3], [1, 3, 12], [2, 3, 9], [4, 3, 4], [4, 5, 13], [3, 5, 5], [4, 6, 15], [5, 6, 4]] # 每个数组数字从左到右依次是每条边的，起点，终点，权重
       # 初始化数组，得到图的二维数组
       e = []
       for i in n:
	   x = []
	   for j in n:
	       if i == j:
		   x.append(0)
	       else:
		   x.append(inf)
	   e.append(x)

       for i in graph:
	   e[i[0]][i[1]] = i[2]

       d = [] # 顶点1到各个顶点的初始化距离
       for item, index in enumerate(e):
	   d.append(item[0][index])

       book = [] # 初始化一个数组来记录某个点是否已经走过
       for i in n:
	   book.append(0)
       book[0] = 1
       for i in n-1:
	   min = inf
	   u = 0
	   for j in n: # 找到当前顶点1直达其他点的最短距离的那个点
	       if book[j] == 0 and d[j] < min:
		   min = d[j]
		   u = j
	   book[u] = 1
	   for k in n: # 判断通过这个点到达其他点距离是否更近，如果更近，则更新数组d
	       if e[u][k] < inf:
		   if d[k] > d[u] + e[u][k]:
		       d[k] = d[u] + e[u][k]
    
     #+END_SRC
     
*** floyd
*** bellman ford
